<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GLB Animation & Bone Editor</title>
  <style>
      * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
      }

      body {
          overflow: hidden;
          background: #1a1a2e;
          font-family: system-ui, -apple-system, sans-serif;
      }

      #canvas-container {
          width: 100vw;
          height: 100vh;
      }

      #ui {
          position: fixed;
          top: 20px;
          left: 20px;
          z-index: 100;
          display: flex;
          flex-direction: column;
          gap: 10px;
      }

      .file-input-label {
          background: #4a4a8a;
          color: white;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 500;
          transition: background 0.2s;
          text-align: center;
          display: block;
      }

      .file-input-label:hover {
          background: #5a5a9a;
      }

      #fbx-input-label {
          background: #8a6a4a;
      }

      #fbx-input-label:hover {
          background: #9a7a5a;
      }

      #fbx-input-label.disabled {
          background: #4a4a4a;
          cursor: not-allowed;
          opacity: 0.6;
      }

      .file-input {
          display: none;
      }

      .control-btn {
          background: #2a8a4a;
          border: none;
          color: white;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 500;
          font-size: 14px;
          transition: background 0.2s;
      }

      .control-btn:hover {
          background: #3a9a5a;
      }

      #play-pause-btn.paused {
          background: #8a4a2a;
      }

      #play-pause-btn.paused:hover {
          background: #9a5a3a;
      }

      #toggle-skeleton-btn {
          background: #6a4a8a;
      }

      #toggle-skeleton-btn:hover {
          background: #7a5a9a;
      }

      #toggle-skeleton-btn.hidden {
          background: #4a4a5a;
      }

      #info {
          position: fixed;
          bottom: 20px;
          left: 20px;
          background: rgba(0, 0, 0, 0.85);
          color: white;
          padding: 15px 20px;
          border-radius: 8px;
          font-size: 14px;
          max-width: 400px;
      }

      #info h3 {
          margin-bottom: 8px;
          color: #8a8aff;
      }

      #animations-list {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
          margin-top: 10px;
      }

      .anim-btn {
          background: #3a3a6a;
          border: none;
          color: white;
          padding: 8px 16px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 13px;
          transition: all 0.2s;
      }

      .anim-btn:hover {
          background: #5a5aaa;
      }

      .anim-btn.active {
          background: #6a6aff;
      }

      .anim-btn.from-fbx {
          background: #6a5a3a;
      }

      .anim-btn.from-fbx:hover {
          background: #8a7a4a;
      }

      .anim-btn.from-fbx.active {
          background: #aa8a4a;
      }

      /* Bone Editor Panel */
      #bone-panel {
          position: fixed;
          top: 20px;
          right: 20px;
          background: rgba(0, 0, 0, 0.9);
          color: white;
          padding: 20px;
          border-radius: 10px;
          width: 320px;
          max-height: calc(100vh - 40px);
          overflow-y: auto;
          z-index: 100;
      }

      #bone-panel h3 {
          color: #ff8a6a;
          margin-bottom: 15px;
          display: flex;
          align-items: center;
          gap: 8px;
      }

      #bone-list {
          max-height: 200px;
          overflow-y: auto;
          border: 1px solid #444;
          border-radius: 6px;
          margin-bottom: 15px;
      }

      .bone-item {
          padding: 6px 12px;
          cursor: pointer;
          border-bottom: 1px solid #333;
          transition: all 0.15s;
          font-size: 12px;
          display: flex;
          align-items: center;
          gap: 6px;
      }

      .bone-item .bone-indent {
          display: inline-block;
          width: 12px;
          border-left: 1px solid #555;
          border-bottom: 1px solid #555;
          height: 10px;
          margin-right: 2px;
          flex-shrink: 0;
      }

      .bone-item::before {
          content: '';
          display: inline-block;
          width: 8px;
          height: 8px;
          border-radius: 50%;
          background: #4a9aff;
          flex-shrink: 0;
      }

      .bone-item:hover {
          background: #3a3a5a;
      }

      .bone-item.selected {
          background: #ff6a4a;
          color: white;
          font-weight: 500;
      }

      .bone-item.selected::before {
          background: #ffff00;
          box-shadow: 0 0 8px #ffff00;
      }

      /* Twist bones styling */
      .bone-item.twist-bone {
          opacity: 0.5;
          font-style: italic;
      }

      .bone-item.twist-bone::before {
          background: #666;
      }

      .bone-item.twist-bone::after {
          content: '(twist)';
          font-size: 10px;
          color: #888;
          margin-left: auto;
      }

      .bone-item:last-child {
          border-bottom: none;
      }

      #rotation-controls {
          display: none;
          flex-direction: column;
          gap: 12px;
      }

      #rotation-controls.visible {
          display: flex;
      }

      #rotation-controls h4 {
          color: #6af;
          margin-bottom: 5px;
      }

      .rotation-axis {
          display: flex;
          flex-direction: column;
          gap: 5px;
      }

      .rotation-axis label {
          display: flex;
          justify-content: space-between;
          align-items: center;
          font-size: 13px;
      }

      .rotation-axis label span.axis-label {
          font-weight: bold;
          width: 20px;
      }

      .rotation-axis label span.axis-label.x { color: #ff6b6b; }
      .rotation-axis label span.axis-label.y { color: #6bff6b; }
      .rotation-axis label span.axis-label.z { color: #6b6bff; }

      .rotation-axis input[type="range"] {
          flex: 1;
          margin: 0 10px;
          accent-color: #6a6aff;
      }

      .rotation-axis input[type="number"] {
          width: 70px;
          background: #2a2a4a;
          border: 1px solid #444;
          color: white;
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 12px;
      }

      #reset-bone-btn {
          background: #6a3a3a;
          border: none;
          color: white;
          padding: 10px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 13px;
          margin-top: 10px;
          transition: background 0.2s;
      }

      #reset-bone-btn:hover {
          background: #8a4a4a;
      }

      #selected-bone-name {
          background: #2a2a4a;
          padding: 10px;
          border-radius: 6px;
          margin-bottom: 15px;
          font-weight: 500;
          color: #ff8a6a;
          text-align: center;
      }

      #loading {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          color: white;
          font-size: 18px;
          display: none;
          text-align: center;
      }

      .spinner {
          width: 40px;
          height: 40px;
          border: 4px solid #333;
          border-top-color: #6a6aff;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin: 0 auto 15px;
      }

      @keyframes spin {
          to { transform: rotate(360deg); }
      }

      #no-bones-msg {
          color: #888;
          font-style: italic;
          padding: 20px;
          text-align: center;
      }

      /* Legend */
      #skeleton-legend {
          margin-top: 15px;
          padding: 10px;
          background: #2a2a3a;
          border-radius: 6px;
          font-size: 12px;
      }

      #skeleton-legend h5 {
          color: #aaa;
          margin-bottom: 8px;
      }

      .legend-item {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 4px;
      }

      .legend-color {
          width: 12px;
          height: 12px;
          border-radius: 50%;
      }

      .legend-color.bone { background: #4a9aff; }
      .legend-color.selected { background: #ffff00; box-shadow: 0 0 6px #ffff00; }
      .legend-color.skeleton { background: #00ffaa; }
      .legend-color.twist { background: #666; }

      /* Gizmo hint */
      #gizmo-hint {
          margin-top: 10px;
          padding: 10px;
          background: #3a3a5a;
          border-radius: 6px;
          font-size: 11px;
          color: #aaa;
      }

      #gizmo-hint strong {
          color: #ff8a6a;
      }

      /* FBX Status */
      #fbx-status {
          margin-top: 10px;
          padding: 10px;
          background: #3a3a2a;
          border-radius: 6px;
          font-size: 12px;
          color: #aa8;
          display: none;
      }

      #fbx-status.visible {
          display: block;
      }

      #fbx-status strong {
          color: #dda;
      }

      /* Scrollbar styling */
      #bone-list::-webkit-scrollbar,
      #bone-panel::-webkit-scrollbar {
          width: 8px;
      }

      #bone-list::-webkit-scrollbar-track,
      #bone-panel::-webkit-scrollbar-track {
          background: #1a1a2e;
          border-radius: 4px;
      }

      #bone-list::-webkit-scrollbar-thumb,
      #bone-panel::-webkit-scrollbar-thumb {
          background: #4a4a6a;
          border-radius: 4px;
      }

      #bone-list::-webkit-scrollbar-thumb:hover,
      #bone-panel::-webkit-scrollbar-thumb:hover {
          background: #5a5a8a;
      }

      /* Animations section styling */
      .anim-section {
          margin-top: 10px;
      }

      .anim-section-title {
          font-size: 11px;
          color: #888;
          margin-bottom: 5px;
          text-transform: uppercase;
      }
  </style>
</head>
<body>
<div id="canvas-container"></div>

<div id="ui">
  <label id="modele-input-label" class="file-input-label">
    üìÅ Charger un mod√®le
    <input type="file" id="modele-input" class="file-input" accept=".glb,.gltf,.fbx">
  </label>
  <label id="fbx-input-label" class="file-input-label disabled">
    üé¨ Charger animation .fbx
    <input type="file" id="fbx-input" class="file-input" accept=".fbx" disabled>
  </label>
  <button id="play-pause-btn" class="control-btn">‚è∏Ô∏è Pause Animation</button>
  <button id="toggle-skeleton-btn" class="control-btn">ü¶¥ Masquer Squelette</button>
</div>

<div id="info">
  <h3>GLB Animation & Bone Editor</h3>
  <p>Chargez un fichier .glb pour visualiser le mod√®le et √©diter les bones.</p>
  <div id="animations-list"></div>
  <div id="fbx-status">
    <strong>Animation FBX:</strong> <span id="fbx-filename"></span>
  </div>
</div>

<div id="bone-panel">
  <h3>ü¶¥ Bones du Skeleton</h3>
  <div id="bone-list">
    <div id="no-bones-msg">Aucun mod√®le charg√©</div>
  </div>
  
  <div id="rotation-controls">
    <div id="selected-bone-name">Aucun bone s√©lectionn√©</div>
    <h4>Rotation (degr√©s)</h4>
    
    <div class="rotation-axis">
      <label>
        <span class="axis-label x">X</span>
        <input type="range" id="rot-x" min="-180" max="180" value="0" step="1">
        <input type="number" id="rot-x-num" min="-180" max="180" value="0" step="1">
      </label>
    </div>
    
    <div class="rotation-axis">
      <label>
        <span class="axis-label y">Y</span>
        <input type="range" id="rot-y" min="-180" max="180" value="0" step="1">
        <input type="number" id="rot-y-num" min="-180" max="180" value="0" step="1">
      </label>
    </div>
    
    <div class="rotation-axis">
      <label>
        <span class="axis-label z">Z</span>
        <input type="range" id="rot-z" min="-180" max="180" value="0" step="1">
        <input type="number" id="rot-z-num" min="-180" max="180" value="0" step="1">
      </label>
    </div>
    
    <button id="reset-bone-btn">üîÑ Reset Rotation</button>
    
    <div id="gizmo-hint">
      <strong>Astuce Gizmo:</strong> Utilisez les cercles color√©s pour tourner le bone.
      Rouge = X, Vert = Y, Bleu = Z
    </div>
  </div>
  
  <div id="skeleton-legend">
    <h5>L√©gende</h5>
    <div class="legend-item">
      <div class="legend-color skeleton"></div>
      <span>Squelette</span>
    </div>
    <div class="legend-item">
      <div class="legend-color bone"></div>
      <span>Bones (cliquez pour s√©lectionner)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color twist"></div>
      <span>Bones twist (non cliquables)</span>
    </div>
    <div class="legend-item">
      <div class="legend-color selected"></div>
      <span>Bone s√©lectionn√©</span>
    </div>
  </div>
</div>

<div id="loading">
  <div class="spinner"></div>
  <p>Chargement...</p>
</div>

<script type="importmap">
  {
      "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
  }
</script>
<!--<script type="importmap">-->
<!--  {-->
<!--      "imports": {-->
<!--          "three": "./node_modules/three/build/three.module.js",-->
<!--          "three/addons/": "./node_modules/three/examples/jsm/"-->
<!--      }-->
<!--  }-->
<!--</script>-->

<script type="module">
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { TransformControls } from 'three/addons/controls/TransformControls.js';

  // Scene setup
  const container = document.getElementById('canvas-container');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a2e);

  // Camera
  const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
  );
  camera.position.set(3, 2, 5);

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  container.appendChild(renderer.domElement);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.target.set(0, 1, 0);

  // Transform Controls (Gizmo)
  const transformControls = new TransformControls(camera, renderer.domElement);
  transformControls.setMode('rotate');
  transformControls.setSize(0.8);
  transformControls.setSpace('local');
  scene.add(transformControls);
  
  window.transformControls = transformControls;

  // Disable orbit controls when using transform controls
  transformControls.addEventListener('dragging-changed', (event) => {
    controls.enabled = !event.value;
  });

  // Update UI when gizmo is used
  transformControls.addEventListener('change', () => {
    if (selectedBone) {
      updateRotationUI();
    }
  });

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
  directionalLight.position.set(5, 10, 7);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 50;
  directionalLight.shadow.camera.left = -10;
  directionalLight.shadow.camera.right = 10;
  directionalLight.shadow.camera.top = 10;
  directionalLight.shadow.camera.bottom = -10;
  scene.add(directionalLight);

  const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
  fillLight.position.set(-5, 5, -5);
  scene.add(fillLight);

  // Ground plane
  const groundGeometry = new THREE.PlaneGeometry(20, 20);
  const groundMaterial = new THREE.MeshStandardMaterial({
    color: 0x2a2a4e,
    roughness: 0.8
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Grid helper
  const gridHelper = new THREE.GridHelper(20, 20, 0x444466, 0x333355);
  scene.add(gridHelper);

  // Animation system
  let mixer = null;
  let mixerFbx = null;
  let currentModel = null;
  let secondaryFbxModel = null;
  let skeletonHelperFbx = null;
  let principalAnimations = [];
  let hipsOriginalPosition;
  let fbxHipsOriginalPosition;
  let fbxAnimations = [];
  let activeAction = null;
  let isPlaying = true;
  const clock = new THREE.Clock();

  // Bone system
  let bones = [];
  let bonesByName = new Map();
  let fbxBonesByName = new Map();
  window.fbxBonesByName = fbxBonesByName;
  window.bonesByName = bonesByName;
  window.THREE = THREE;
  
  let selectedBone = null;
  let selectedBoneIndex = -1;
  let skeletonHelper = null;
  let skeletonVisible = true;

  // Bone visualization
  let boneMarkersGroup = new THREE.Group();
  scene.add(boneMarkersGroup);
  let boneMarkers = [];
  let selectableBoneMarkers = [];

  // Raycaster for clicking
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // Original bone rotations storage
  const originalBoneRotations = new Map();
  window.originalBoneRotations = originalBoneRotations;

  // Loaders
  const gltfLoader = new GLTFLoader();
  const fbxLoader = new FBXLoader();

  // Check if bone is a twist bone
  function isTwistBone(bone) {
    const name = (bone.name || '').toLowerCase();
    return name.includes('twist');
  }

  // Create bone marker sphere
  function createBoneMarker(bone, index, isSelected = false) {
    const isTwist = isTwistBone(bone);
    const size = isSelected ? 0.045 : (isTwist ? 0.02 : 0.03);

    let color;
    if (isSelected) {
      color = 0xffff00;
    } else if (isTwist) {
      color = 0x666666;
    } else {
      color = 0x4a9aff;
    }

    const geometry = new THREE.SphereGeometry(size, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: isSelected ? 1.0 : (isTwist ? 0.4 : 0.8),
      depthTest: false
    });

    const sphere = new THREE.Mesh(geometry, material);
    sphere.renderOrder = 999;
    sphere.userData.boneIndex = index;
    sphere.userData.isBoneMarker = true;
    sphere.userData.isTwistBone = isTwist;
    sphere.userData.isSelectable = !isTwist;

    if (isSelected) {
      const glowGeo = new THREE.SphereGeometry(size * 1.5, 16, 16);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xffff00,
        transparent: true,
        opacity: 0.3,
        depthTest: false
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      glow.renderOrder = 998;
      sphere.add(glow);
    }

    return sphere;
  }

  // Update all bone markers positions
  function updateBoneMarkers() {
    bones.forEach((bone, index) => {
      if (boneMarkers[index]) {
        bone.getWorldPosition(boneMarkers[index].position);
      }
    });
  }

  // Create bone markers for all bones
  function createAllBoneMarkers() {
    boneMarkersGroup.clear();
    boneMarkers = [];
    selectableBoneMarkers = [];

    bones.forEach((bone, index) => {
      const marker = createBoneMarker(bone, index, index === selectedBoneIndex);
      boneMarkersGroup.add(marker);
      boneMarkers.push(marker);

      if (!isTwistBone(bone)) {
        selectableBoneMarkers.push(marker);
      }
    });

    updateBoneMarkers();
  }

  // Update selected bone marker
  function updateSelectedBoneMarker() {
    createAllBoneMarkers();
  }

  // Enable/disable FBX input
  function setFbxInputEnabled(enabled) {
    const fbxInput = document.getElementById('fbx-input');
    const fbxLabel = document.getElementById('fbx-input-label');

    fbxInput.disabled = !enabled;
    if (enabled) {
      fbxLabel.classList.remove('disabled');
    } else {
      fbxLabel.classList.add('disabled');
    }
  }

  // Load GLB file
  function loadPrincipal(url, filename) {
    const loading = document.getElementById('loading');
    loading.style.display = 'block';

    // Remove previous model
    if (currentModel) {
      scene.remove(currentModel);
      currentModel.traverse((child) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(m => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
    }

    // Clear skeleton helper
    if (skeletonHelper) {
      scene.remove(skeletonHelper);
      skeletonHelper.dispose();
      skeletonHelper = null;
    }

    // Detach transform controls
    transformControls.detach();

    // Clear bone markers
    boneMarkersGroup.clear();
    boneMarkers = [];
    selectableBoneMarkers = [];
    selectedBone = null;
    selectedBoneIndex = -1;
    bones = [];
    bonesByName.clear();
    originalBoneRotations.clear();
    principalAnimations = [];
    fbxAnimations = [];

    if (mixer) {
      mixer.stopAllAction();
      mixer = null;
    }

    // Disable FBX input until model is loaded
    setFbxInputEnabled(false);
    document.getElementById('fbx-status').classList.remove('visible');
    
    if(filename.endsWith(".gltf") || filename.endsWith(".glb")) {
      gltfLoader.load(
          url,
          (gltf) => {
            loading.style.display = 'none';
  
            currentModel = gltf.scene;
            principalAnimations = gltf.animations;
            
            manageCurrentModelAfterLoad();
          },
          (progress) => {
            const percent = (progress.loaded / progress.total * 100).toFixed(0);
            loading.querySelector('p').textContent = `Chargement... ${percent}%`;
          },
          (error) => {
            loading.style.display = 'none';
            console.error('Erreur de chargement GLB:', error);
            updateInfo('Erreur lors du chargement du fichier GLB.');
          }
      );
    }else if(filename.endsWith(".fbx")) {
      fbxLoader.load(
          url,
          (fbx) => {
            loading.style.display = 'none';

            currentModel = fbx;
            principalAnimations = fbx.animations;

            manageCurrentModelAfterLoad();
          },
          (progress) => {
            const percent = (progress.loaded / progress.total * 100).toFixed(0);
            loading.querySelector('p').textContent = `Chargement... ${percent}%`;
          },
          (error) => {
            loading.style.display = 'none';
            console.error('Erreur de chargement FBX:', error);
            updateInfo('Erreur lors du chargement du fichier FBX.');
          }
      );
    }
  }
  
  function manageCurrentModelAfterLoad() {
    let skinnedMesh = null;

    // Enable shadows and collect bones
    currentModel.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
      if (child.isSkinnedMesh && !skinnedMesh) {
        skinnedMesh = child;
      }
      if (child.isBone) {
        bones.push(child);
        bonesByName.set(child.name, child);
        originalBoneRotations.set(child.uuid, child.rotation.clone());
      }
    });
    
    // Center and scale model
    const box = new THREE.Box3().setFromObject(currentModel);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());

    const maxDim = Math.max(size.x, size.y, size.z);
    const scale = 2 / maxDim;
    currentModel.scale.multiplyScalar(scale);

    // Recalculate after scaling
    box.setFromObject(currentModel);
    box.getCenter(center);
    currentModel.position.sub(center);
    currentModel.position.y += (size.y * scale) / 2;

    scene.add(currentModel);
    
    currentModel.updateWorldMatrix(true, true);
    hipsOriginalPosition = bonesByName.get("Hip")?.getWorldPosition(new THREE.Vector3());

    // Create skeleton helper
    if (skinnedMesh && skinnedMesh.skeleton) {
      skeletonHelper = new THREE.SkeletonHelper(currentModel);
      skeletonHelper.material.linewidth = 2;
      skeletonHelper.material.color.setHex(0x00ffaa);
      skeletonHelper.visible = skeletonVisible;
      scene.add(skeletonHelper);
    }

    // Create bone markers
    createAllBoneMarkers();

    // Setup animation mixer
    mixer = new THREE.AnimationMixer(currentModel);

    if (principalAnimations.length > 0) {
      updateAnimationsList();
      //playAnimation(0, 'glb');
    } else {
      updateAnimationsList();
      updateInfo('Mod√®le charg√©. Aucune animation GLB trouv√©e.');
    }

    // Update bone list UI
    updateBoneList();

    // Enable FBX input
    setFbxInputEnabled(true);

    // Adjust camera
    const distance = Math.max(size.x, size.y, size.z) * scale * 2;
    camera.position.set(distance, distance * 0.7, distance);
    controls.target.set(0, (size.y * scale) / 2, 0);
    controls.update();
  }

  // Load FBX file and apply animations to current model
  function loadFBXAnimation(url, filename) {
    if (!currentModel || !mixer) {
      updateInfo('Veuillez d\'abord charger un mod√®le GLB.');
      return;
    }

    const loading = document.getElementById('loading');
    loading.style.display = 'block';
    loading.querySelector('p').textContent = 'Chargement animation FBX...';

    // Remove previous secondary FBX if any
    if (secondaryFbxModel) {
      scene.remove(secondaryFbxModel);
      secondaryFbxModel.traverse((child) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(m => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
      secondaryFbxModel = null;
    }
    if (skeletonHelperFbx) {
      scene.remove(skeletonHelperFbx);
      skeletonHelperFbx = null;
    }
    if (mixerFbx) {
      mixerFbx.stopAllAction();
      mixerFbx = null;
    }

    fbxLoader.load(
        url,
        (fbx) => {
          loading.style.display = 'none';

          // Add FBX model to scene
          secondaryFbxModel = fbx;

          // Enable shadows
          fbx.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          // Scale and position the FBX model next to the main model
          const box = new THREE.Box3().setFromObject(fbx);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());

          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 4 / maxDim;
          fbx.scale.multiplyScalar(scale);

          // Recalculate after scaling
          box.setFromObject(fbx);
          box.getCenter(center);
          fbx.rotation.y += Math.PI / 2; // Rotate to face the same direction
          fbx.position.sub(center);
          fbx.position.y += (size.y * scale) / 2;
          fbx.position.z += (size.z * scale) * 2; // Position to the right of main model

          scene.add(fbx);

          // Create skeleton helper for FBX
          skeletonHelperFbx = new THREE.SkeletonHelper(fbx);
          skeletonHelperFbx.material.linewidth = 2;
          skeletonHelperFbx.material.color.setHex(0xffaa00); // Orange color for FBX
          skeletonHelperFbx.visible = skeletonVisible;
          scene.add(skeletonHelperFbx);

          // Create mixer for FBX model and play its animation
          const fbxAnims = fbx.animations || [];
          if (fbxAnims.length > 0) {
            mixerFbx = new THREE.AnimationMixer(fbx);
            activeAction = mixerFbx.clipAction(fbxAnims[0]);
            activeAction.play();
          }

          // FBX bones are accessed differently - collect bone names from the loaded FBX
          fbxBonesByName.clear();

          fbx.traverse((child) => {
            if (child.isBone) {
              // Remove mixamorig prefix if present
              const cleanName = child.name.replace(/^mixamorig[_:1-9]?/i, '');
              if(!fbxBonesByName.has(cleanName)) {
                fbxBonesByName.set(cleanName, child);
              }
            }
          });
          
          fbx.updateWorldMatrix(true, true);
          fbxHipsOriginalPosition = fbxBonesByName.get("Hips").getWorldPosition(new THREE.Vector3());
          
          if (fbxAnimations.length > 0) {
            // Update animations list
            updateAnimationsList();

            // Play first FBX animation
            playAnimation(0, 'fbx');

            // Show FBX status
            document.getElementById('fbx-filename').textContent = filename;
            document.getElementById('fbx-status').classList.add('visible');

            updateInfo(`${fbxAnimations.length} animation(s) FBX charg√©e(s) et appliqu√©e(s).`);
          } else {
            updateInfo('Aucune animation compatible trouv√©e dans le FBX. V√©rifiez que les noms des bones correspondent.');
          }
        },
        (progress) => {
          const percent = (progress.loaded / progress.total * 100).toFixed(0);
          loading.querySelector('p').textContent = `Chargement FBX... ${percent}%`;
        },
        (error) => {
          loading.style.display = 'none';
          console.error('Erreur de chargement FBX:', error);
          updateInfo('Erreur lors du chargement du fichier FBX.');
        }
    );
  }

  
  const boneMapping = {
    // // Racine et bassin
    "Hips": ["Hip", "Pelvis"/*, "Waist"*/],             // ou "Pelvis"
    //
    // // Colonne vert√©brale
    "Spine": ["Waist"],
    "Spine1": ["Spine01"],
    "Spine2": ["Spine02"],
    // "Spine": ["Spine01"],
    // "Spine2": ["Spine02"],
    //
    // // Cou et t√™te
    "Neck": ["NeckTwist01", "NeckTwist02"],     // ou "NeckTwist02"
    "Head": ["Head"],
    //
    // // Jambe gauche
    "LeftUpLeg": ["L_Thigh"/*, "L_Thigh_Twist01", "L_Thigh_Twist02"*/],
    "LeftLeg": ["L_Calf"],
    "LeftToeBase": ["L_Foot"],

    // Jambe droite
    "RightUpLeg": ["R_Thigh"/*, "R_Thigh_Twist01", "R_Thigh_Twist02"*/],
    "RightLeg": ["R_Calf"],
    "RightToeBase": ["R_Foot"],
    //
    // // Bras gauche
    "LeftShoulder": ["L_Clavicle"],
    "LeftArm": ["L_Upperarm"],
    "LeftForeArm": ["L_Forearm"],
    "LeftHand": ["L_Hand"],
    //
    // // Bras droit
    "RightShoulder": ["R_Clavicle"],
    "RightArm": ["R_Upperarm"],
    "RightForeArm": ["R_Forearm"],
    "RightHand": ["R_Hand"]
  };
  
  window.boneMapping = boneMapping;
  
  function matchFbxAnimationToPrincipal(){
    // Bone mapping from Mixamo FBX to GLB model bones
    
    const group = new THREE.Group();
    
    bonesByName.forEach((bone) => {
      const originalRot = originalBoneRotations.get(bone.uuid);
      if (originalRot) {
        bone.rotation.copy(originalRot);
      }
    })
    
    fbxBonesByName.forEach((bone, name) => {
      const mappedBoneName = boneMapping[name];
      if(mappedBoneName) {
        for(let i=0; i<mappedBoneName.length; i++) {
          const testBoneName = mappedBoneName[i];
          const targetBone = bonesByName.get(testBoneName);
          if (targetBone) {
            alignBones(bone, targetBone);
          }
        }
      }
      else if(bonesByName.get(name)){
        // Direct name match
        const targetBone = bonesByName.get(name);
        alignBones(bone, targetBone);
      }
    })


    // const fbxDiff = fbxBonesByName.get("Hips").position.clone().sub(fbxHipsOriginalPosition);
    // bonesByName.get("Hip").position.copy(hipsOriginalPosition).add(fbxDiff.multiplyScalar(fbxHipsOriginalPosition.length/hipsOriginalPosition.length));
    
    // bonesByName.get("Head").rotation.copy(fbxBonesByName.get("Head").rotation);
    //bonesByName.get("NeckTwist01").rotation.copy(fbxBonesByName.get("Neck").rotation);
    bonesByName.get("L_Clavicle").rotateY(-Math.PI/2);
    bonesByName.get("R_Clavicle").rotateY(Math.PI/2);
    
    rotateOnParent(bonesByName.get("R_Upperarm"), 0, -Math.PI/2, 0);
    bonesByName.get("R_UpperarmTwist01").rotateY(Math.PI/2);
    bonesByName.get("R_Hand").rotateY(Math.PI/2);
    
    rotateOnParent(bonesByName.get("L_Upperarm"), 0, Math.PI/2, 0);
    bonesByName.get("L_UpperarmTwist01").rotateY(-Math.PI/2);
    bonesByName.get("L_Hand").rotateY(-Math.PI/2);

    bonesByName.get("Pelvis").rotateY(Math.PI);
    rotateOnParent(bonesByName.get("L_Thigh"), 0, Math.PI, 0);
    rotateOnParent(bonesByName.get("R_Thigh"), 0, Math.PI, 0);
    bonesByName.get("Waist").rotateY(Math.PI);

    rotateOnParent(bonesByName.get("L_Clavicle"), 0, Math.PI, 0);
    rotateOnParent(bonesByName.get("R_Clavicle"), 0, Math.PI, 0);

    bonesByName.get("Head").rotation.x *= -1;
    // bonesByName.get("Head").rotation.y *= -1;
    bonesByName.get("Head").rotation.z *= -1;

    // bonesByName.get("Head").rotation.x *= -1;
    // bonesByName.get("Head").rotation.z *= -1;
    
    bonesByName.get("NeckTwist01").rotation.x *= -1;
    // bonesByName.get("NeckTwist01").rotation.y *= -1;
    bonesByName.get("NeckTwist01").rotation.z *= -1;
    //
    bonesByName.get("NeckTwist02").rotation.x *= -1;
    // bonesByName.get("NeckTwist02").rotation.y *= -1;
    bonesByName.get("NeckTwist02").rotation.z *= -1;

    bonesByName.get("Spine01").rotation.x *= -1;
    // bonesByName.get("Spine01").rotation.y *= -1;
    bonesByName.get("Spine01").rotation.z *= -1;
    //
    bonesByName.get("Spine02").rotation.x *= -1;
    // bonesByName.get("Spine02").rotation.y *= -1;
    bonesByName.get("Spine02").rotation.z *= -1;

  }
  
  function rotateOnParent(bone, rx, ry, rz) {
    const parent = bone.parent;
    const group = new THREE.Group();
    parent.add(group);
    group.position.copy(bone.position);
    group.updateWorldMatrix(false, false);

    group.attach(bone);
    group.rotateX(rx);
    group.rotateY(ry);
    group.rotateZ(rz);
    parent.attach(bone);
  }

  // On pr√©pare des objets r√©utilisables pour √©viter le Garbage Collection (performance)
  const mSourceRot = new THREE.Matrix4();
  const mParentInvRot = new THREE.Matrix4();
  const mLocalTarget = new THREE.Matrix4();

  /**
   * Aligne la rotation mondiale de boneCible sur celle de boneSource
   */
  function alignBones(boneSource, boneCible) {
    // 1. Extraire la rotation mondiale pure de la SOURCE
    // .extractRotation ignore le scale et la position de la matrixWorld
    mSourceRot.extractRotation(boneSource.matrixWorld);

    const parentCible = boneCible.parent;

    if (parentCible) {
      // 2. Extraire la rotation mondiale du PARENT de la cible
      mParentInvRot.extractRotation(parentCible.matrixWorld);

      // 3. Inverser la rotation du parent
      mParentInvRot.invert();

      // 4. Calculer la rotation locale : InverseParent * Source
      // Cela nous donne la rotation n√©cessaire dans l'espace du parent
      mLocalTarget.multiplyMatrices(mParentInvRot, mSourceRot);

      // 5. Appliquer √† l'os cible
      boneCible.quaternion.setFromRotationMatrix(mLocalTarget);
    } else {
      // Si pas de parent, on applique directement la rotation extraite
      boneCible.quaternion.setFromRotationMatrix(mSourceRot);
    }

    // Important : mettre √† jour pour les futurs calculs d'enfants dans la m√™me frame
    boneCible.updateMatrixWorld();
  }

  // Play specific animation
  function playAnimation(index, source = 'glb') {
    if (!mixer) return;

    const animations = source === 'glb' ? principalAnimations : fbxAnimations;
    if (index >= animations.length) return;

    const clip = animations[index];

    if (activeAction) {
      activeAction.fadeOut(2.0);
    }

    activeAction = mixer.clipAction(clip);
    activeAction.reset();
    activeAction.fadeIn(2.0);
    activeAction.play();

    if (!isPlaying) {
      activeAction.paused = true;
    }

    // Update button states
    document.querySelectorAll('.anim-btn').forEach(btn => {
      const btnSource = btn.dataset.source;
      const btnIndex = parseInt(btn.dataset.index);
      btn.classList.toggle('active', btnSource === source && btnIndex === index);
    });

    updateInfo(`Animation: "${clip.name}" (${clip.duration.toFixed(2)}s) - Source: ${source.toUpperCase()}`);
  }

  // Toggle play/pause
  function togglePlayPause() {
    isPlaying = !isPlaying;

    const btn = document.getElementById('play-pause-btn');
    if (isPlaying) {
      btn.textContent = '‚è∏Ô∏è Pause Animation';
      btn.classList.remove('paused');
      if (activeAction) {
        activeAction.paused = false;
      }
    } else {
      btn.textContent = '‚ñ∂Ô∏è Play Animation';
      btn.classList.add('paused');
      if (activeAction) {
        activeAction.paused = true;
      }
    }
  }

  // Toggle skeleton visibility
  function toggleSkeleton() {
    skeletonVisible = !skeletonVisible;

    const btn = document.getElementById('toggle-skeleton-btn');
    if (skeletonVisible) {
      btn.textContent = 'ü¶¥ Masquer Squelette';
      btn.classList.remove('hidden');
    } else {
      btn.textContent = 'ü¶¥ Afficher Squelette';
      btn.classList.add('hidden');
    }

    if (skeletonHelper) {
      skeletonHelper.visible = skeletonVisible;
    }

    if (skeletonHelperFbx) {
      skeletonHelperFbx.visible = skeletonVisible;
    }

    boneMarkersGroup.visible = skeletonVisible;
  }

  // Update animations list UI
  function updateAnimationsList() {
    const listContainer = document.getElementById('animations-list');
    listContainer.innerHTML = '';

    const hasGlbAnims = principalAnimations.length > 0;
    const hasFbxAnims = fbxAnimations.length > 0;

    if (!hasGlbAnims && !hasFbxAnims) {
      listContainer.innerHTML = '<p style="color: #888;">Aucune animation</p>';
      return;
    }

    // GLB Animations
    if (hasGlbAnims) {
      const glbSection = document.createElement('div');
      glbSection.className = 'anim-section';

      const glbTitle = document.createElement('div');
      glbTitle.className = 'anim-section-title';
      glbTitle.textContent = 'GLB';
      glbSection.appendChild(glbTitle);

      const glbButtons = document.createElement('div');
      glbButtons.style.display = 'flex';
      glbButtons.style.flexWrap = 'wrap';
      glbButtons.style.gap = '8px';

      principalAnimations.forEach((clip, index) => {
        const btn = document.createElement('button');
        btn.className = 'anim-btn';
        btn.textContent = clip.name || `Animation ${index + 1}`;
        btn.dataset.source = 'glb';
        btn.dataset.index = index;
        btn.addEventListener('click', () => playAnimation(index, 'glb'));
        glbButtons.appendChild(btn);
      });

      glbSection.appendChild(glbButtons);
      listContainer.appendChild(glbSection);
    }

    // FBX Animations
    if (hasFbxAnims) {
      const fbxSection = document.createElement('div');
      fbxSection.className = 'anim-section';

      const fbxTitle = document.createElement('div');
      fbxTitle.className = 'anim-section-title';
      fbxTitle.textContent = 'FBX';
      fbxSection.appendChild(fbxTitle);

      const fbxButtons = document.createElement('div');
      fbxButtons.style.display = 'flex';
      fbxButtons.style.flexWrap = 'wrap';
      fbxButtons.style.gap = '8px';

      fbxAnimations.forEach((clip, index) => {
        const btn = document.createElement('button');
        btn.className = 'anim-btn from-fbx';
        btn.textContent = clip.name || `FBX Anim ${index + 1}`;
        btn.dataset.source = 'fbx';
        btn.dataset.index = index;
        btn.addEventListener('click', () => playAnimation(index, 'fbx'));
        fbxButtons.appendChild(btn);
      });

      fbxSection.appendChild(fbxButtons);
      listContainer.appendChild(fbxSection);
    }
  }

  // Update bone list UI with hierarchy
  function updateBoneList() {
    const listContainer = document.getElementById('bone-list');
    listContainer.innerHTML = '';

    if (bones.length === 0) {
      listContainer.innerHTML = '<div id="no-bones-msg">Aucun bone trouv√©</div>';
      document.getElementById('rotation-controls').classList.remove('visible');
      return;
    }

    // Build bone index map
    const boneIndexMap = new Map();
    bones.forEach((bone, index) => {
      boneIndexMap.set(bone, index);
    });

    // Find root bones (bones whose parent is not in the bones array)
    const rootBones = bones.filter(bone => {
      let parent = bone.parent;
      while (parent) {
        if (boneIndexMap.has(parent)) return false;
        parent = parent.parent;
      }
      return true;
    });

    // Recursive function to add bone and its children
    function addBoneToList(bone, depth) {
      const index = boneIndexMap.get(bone);
      if (index === undefined) return;

      const item = document.createElement('div');
      item.className = 'bone-item';

      if (isTwistBone(bone)) {
        item.classList.add('twist-bone');
      }

      // Add indentation
      for (let i = 0; i < depth; i++) {
        const indent = document.createElement('span');
        indent.className = 'bone-indent';
        item.appendChild(indent);
      }

      const nameSpan = document.createElement('span');
      nameSpan.textContent = bone.name || `Bone ${index + 1}`;
      item.appendChild(nameSpan);

      item.dataset.index = index;
      item.addEventListener('click', () => selectBone(index));
      listContainer.appendChild(item);

      // Add children (only bones that are in our bones array)
      bone.children.forEach(child => {
        if (child.isBone && boneIndexMap.has(child)) {
          addBoneToList(child, depth + 1);
        }
      });
    }

    // Start from root bones
    rootBones.forEach(rootBone => {
      addBoneToList(rootBone, 0);
    });
  }

  // Select a bone
  function selectBone(index) {
    selectedBone = bones[index];
    selectedBoneIndex = index;

    document.querySelectorAll('.bone-item').forEach((item) => {
      item.classList.toggle('selected', parseInt(item.dataset.index) === index);
    });

    const selectedItem = document.querySelector(`.bone-item[data-index="${index}"]`);
    if (selectedItem) {
      selectedItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    document.getElementById('rotation-controls').classList.add('visible');
    document.getElementById('selected-bone-name').textContent = selectedBone.name || `Bone ${index + 1}`;

    updateRotationUI();
    updateSelectedBoneMarker();
    transformControls.attach(selectedBone);
  }

  // Deselect bone
  function deselectBone() {
    selectedBone = null;
    selectedBoneIndex = -1;

    document.querySelectorAll('.bone-item').forEach(item => {
      item.classList.remove('selected');
    });

    document.getElementById('rotation-controls').classList.remove('visible');

    transformControls.detach();
    updateSelectedBoneMarker();
  }

  // Update rotation UI from bone
  function updateRotationUI() {
    if (!selectedBone) return;

    const rot = selectedBone.rotation;
    const toDeg = THREE.MathUtils.radToDeg;

    document.getElementById('rot-x').value = toDeg(rot.x);
    document.getElementById('rot-x-num').value = Math.round(toDeg(rot.x));
    document.getElementById('rot-y').value = toDeg(rot.y);
    document.getElementById('rot-y-num').value = Math.round(toDeg(rot.y));
    document.getElementById('rot-z').value = toDeg(rot.z);
    document.getElementById('rot-z-num').value = Math.round(toDeg(rot.z));
  }

  // Update bone rotation
  function updateBoneRotation(axis, value) {
    if (!selectedBone) return;

    const toRad = THREE.MathUtils.degToRad;
    selectedBone.rotation[axis] = toRad(value);

    document.getElementById(`rot-${axis}`).value = value;
    document.getElementById(`rot-${axis}-num`).value = Math.round(value);
  }

  // Reset selected bone rotation
  function resetBoneRotation() {
    if (!selectedBone) return;

    const originalRot = originalBoneRotations.get(selectedBone.uuid);
    if (originalRot) {
      selectedBone.rotation.copy(originalRot);
      updateRotationUI();
    }
  }

  // Update info panel
  function updateInfo(message) {
    const info = document.getElementById('info');
    info.querySelector('p').textContent = message;
  }

  // Handle click for bone selection
  function onCanvasClick(event) {
    if (event.target !== renderer.domElement) return;

    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(selectableBoneMarkers, false);

    if (intersects.length > 0) {
      const clickedMarker = intersects[0].object;
      if (clickedMarker.userData.isBoneMarker && clickedMarker.userData.isSelectable) {
        const boneIndex = clickedMarker.userData.boneIndex;
        selectBone(boneIndex);
      }
    }
  }

  // Event listeners
  document.getElementById('modele-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const url = URL.createObjectURL(file);
      loadPrincipal(url, file.name);
    }
  });

  document.getElementById('fbx-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const url = URL.createObjectURL(file);
      loadFBXAnimation(url, file.name);
    }
  });

  document.getElementById('play-pause-btn').addEventListener('click', togglePlayPause);
  document.getElementById('toggle-skeleton-btn').addEventListener('click', toggleSkeleton);

  renderer.domElement.addEventListener('click', onCanvasClick);

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      deselectBone();
    }
  });

  ['x', 'y', 'z'].forEach(axis => {
    document.getElementById(`rot-${axis}`).addEventListener('input', (e) => {
      updateBoneRotation(axis, parseFloat(e.target.value));
    });
    document.getElementById(`rot-${axis}-num`).addEventListener('input', (e) => {
      let val = parseFloat(e.target.value) || 0;
      val = Math.max(-180, Math.min(180, val));
      updateBoneRotation(axis, val);
    });
  });

  document.getElementById('reset-bone-btn').addEventListener('click', resetBoneRotation);

  // Drag and drop
  document.addEventListener('dragover', (e) => {
    e.preventDefault();
    document.body.style.opacity = '0.7';
  });

  document.addEventListener('dragleave', () => {
    document.body.style.opacity = '1';
  });

  document.addEventListener('drop', (e) => {
    e.preventDefault();
    document.body.style.opacity = '1';

    const file = e.dataTransfer.files[0];
    if (file) {
      if (file.name.endsWith('.glb') || file.name.endsWith('.gltf')) {
        const url = URL.createObjectURL(file);
        loadPrincipal(url);
      } else if (file.name.endsWith('.fbx') && currentModel) {
        const url = URL.createObjectURL(file);
        loadFBXAnimation(url, file.name);
      }
    }
  });

  // Handle resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();

    // Update secondary FBX animation
    if (mixerFbx) {
      mixerFbx.update(delta);
      if(isPlaying){
        matchFbxAnimationToPrincipal();
      }
    }
    else if (mixer) {
      mixer.update(delta);

      if (isPlaying && selectedBone) {
        updateRotationUI();
      }
    }

    updateBoneMarkers();

    controls.update();
    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
